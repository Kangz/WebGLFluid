<html>
    <head>
        <title>Unnamed</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

        <style>
            * { margin:0; padding:0; }
        </style>

        <script type="text/javascript" src="external/gl-matrix-min.js"></script>
        <script type="text/javascript" src="lib/glExtras.js"></script>
        <script type="text/javascript" src="lib/glUtils.js"></script>

        <script id="shader-src" type="x-shader/x-fragment">
            //----- half-float-texture
            // A halfish A is a float encoded on 16 bits as follows
            // |      15       |1|
            // |       e       |s|
            // With e being a float encoded in a 6.9 fixed point format.
            // The corresponding float is:
            //     F = sign * exp2(e) / 2^16;
            // That way the range of this representation goes from about 2^16 to 2^-16
            // which is about the range representable by a half float.

            float round(float f) {
                return floor(f + 0.5);
            }

            float floatToHalfish(float f) {
                float sign = sign(f) * 0.5 + 0.5;
                float exponent = log2(abs(f));
                float e = round(exponent * 512.0 + (16.0 * 512.0));
                return e * 2.0 + sign;
            }

            float halfishToFloat(float a) {
                float sign = mod(a, 2.0);
                float e = (a - sign) / 2.0;
                float exponent = exp2(e / 512.0 - 16.0);
                return exponent * (sign * 2.0 - 1.0);
            }

            // Samples a float texture using one of our halfish formats.
            // There is no linear interpolation.
            vec3 packRGB565(float a) {
                float unpacked = floatToHalfish(a);

                float blue = mod(unpacked, 32.0);
                float rg = (unpacked - blue) / 32.0;
                float green = mod(rg, 64.0);
                float red = (rg - green) / 64.0;

                return vec3(red / 31.0, green / 63.0, blue / 31.0);
            }

            float unpackRGB565(vec3 color) {
                float red = round(color.r * 31.0);
                float green = round(color.g * 63.0);
                float blue = round(color.b * 31.0);

                float unpacked = ((red * 64.0) + green) * 32.0 + blue;
                return halfishToFloat(unpacked);
            }

            vec4 packRGBA8(float a) {
                float unpacked = floatToHalfish(a);

                float y = mod(unpacked, 256.0);
                float x = (unpacked - y) / 256.0;

                return vec4(x / 255.0, y / 255.0, 0.0, 0.0);
            }

            float unpackRGBA8(vec4 color) {
                float x = round(color.x * 255.0);
                float y = round(color.y * 255.0);

                float unpacked = x * 256.0 + y;
                return halfishToFloat(unpacked);
            }

            /*
            // RGB565
            float textureFloat1(sampler2D texture, vec2 texCoord) {
                return unpackRGB565(texture2D(texture, texCoord).xyz) / 256.0;
            }

            vec4 float1FragColor(float a) {
                return vec4(packRGB565(a * 256.0), 0.0);
            }
            */

            // Regular RGBA32F
            float textureFloat1(sampler2D texture, vec2 texCoord) {
                return texture2D(texture, texCoord).x / 256.0;
            }

            vec4 float1FragColor(float a) {
                return vec4(a * 256.0, 0.0, 0.0, 0.0);
            }

            /*
            // RGBA8
            float textureFloat1(sampler2D texture, vec2 texCoord) {
                return unpackRGBA8(texture2D(texture, texCoord)) / 256.0;
            }

            vec4 float1FragColor(float a) {
                return packRGBA8(a * 256.0);
            }
            */

            //----- common-fluid-compute
            @include(half-float-texture)

            uniform sampler2D uVelocity;
            uniform sampler2D uDivergence;
            uniform sampler2D uPressure;
            uniform sampler2D uForce;

            uniform float uDt;
            uniform vec2 uResolution;
            uniform vec2 uInvResolution;
            uniform vec2 uAspectRatio;
            uniform float uCellSize;

            varying vec2 vTexCoord;
            varying vec2 vWorldPos;

            vec2 worldToTexCoord(vec2 world) {
                return (world / uAspectRatio) / 2.0 + vec2(0.5, 0.5);
            }

            vec2 texCoordToWorld(vec2 texCoord) {
                return (texCoord - vec2(0.5, 0.5)) * 2.0 * uAspectRatio;
            }

            vec2 sampleVelocity(sampler2D velocity, vec2 texCoord) {
                vec2 offset = vec2(0.0, 0.0);
                vec2 multiplier = vec2(1.0, 1.0);

                // TODO replace with the obstacle texture
                if (texCoord.x < 0.0) {
                    offset.x = uInvResolution.x;
                    multiplier.x = -1.0;
                } else if (texCoord.x > 1.0) {
                    offset.x = -uInvResolution.x;
                    multiplier.x = -1.0;
                }
                if (texCoord.y < 0.0) {
                    offset.y = uInvResolution.y;
                    multiplier.y = -1.0;
                } else if (texCoord.y > 1.0) {
                    offset.y = -uInvResolution.y;
                    multiplier.y = -1.0;
                }

                return multiplier * texture2D(velocity, texCoord + offset).xy;
            }

            float samplePressure(sampler2D pressure, vec2 texCoord) {
                vec2 offset = vec2(0.0, 0.0);

                // TODO replace with the obstacle texture
                if (texCoord.x < 0.0) {
                    offset.x = uInvResolution.x;
                } else if (texCoord.x > 1.0) {
                    offset.x = -uInvResolution.x;
                }
                if (texCoord.y < 0.0) {
                    offset.y = uInvResolution.y;
                } else if (texCoord.y > 1.0) {
                    offset.y = -uInvResolution.y;
                }

                return textureFloat1(pressure, texCoord + offset);
            }

            vec2 getAdvectionPosition(sampler2D velocity, vec2 worldPos) {
                //TODO try MacCormack
                return worldPos - sampleVelocity(uVelocity, worldToTexCoord(worldPos)) * uDt;
            }

            //----- advect-velocity
            precision highp float;
            @include(common-fluid-compute)

            void main() {
                vec2 advectionPos = getAdvectionPosition(uVelocity, vWorldPos);
                gl_FragColor = vec4(texture2D(uVelocity, worldToTexCoord(advectionPos)).xy, 0.0, 0.0);
            }

            //----- apply-forces
            precision highp float;
            @include(common-fluid-compute)

            void main() {
                vec2 velocity = sampleVelocity(uVelocity, vTexCoord);
                vec2 force = texture2D(uForce, vTexCoord).xy;
                gl_FragColor = vec4(velocity + force * uDt, 0.0, 0.0);
            }

            //----- compute-divergence
            precision highp float;
            @include(common-fluid-compute)

            void main() {
                vec2 left = sampleVelocity(uVelocity, vTexCoord - vec2(uInvResolution.x, 0.0));
                vec2 right = sampleVelocity(uVelocity, vTexCoord + vec2(uInvResolution.x, 0.0));
                vec2 bottom = sampleVelocity(uVelocity, vTexCoord - vec2(0.0, uInvResolution.y));
                vec2 top = sampleVelocity(uVelocity, vTexCoord + vec2(0.0, uInvResolution.y));

                float divergence = 0.5 / uCellSize * (right.x - left.x + top.y - bottom.y);
                gl_FragColor = float1FragColor(divergence);
            }

            //----- solve-pressure
            precision highp float;
            @include(common-fluid-compute)

            void main() {
                float left = samplePressure(uPressure, vTexCoord - vec2(uInvResolution.x, 0.0));
                float right = samplePressure(uPressure, vTexCoord + vec2(uInvResolution.x, 0.0));
                float bottom = samplePressure(uPressure, vTexCoord - vec2(0.0, uInvResolution.y));
                float top = samplePressure(uPressure, vTexCoord + vec2(0.0, uInvResolution.y));

                float divergence = textureFloat1(uDivergence, vTexCoord);
                float pressure = (left + right + bottom + top - divergence * uCellSize * uCellSize) / 4.0;
                gl_FragColor = float1FragColor(pressure);
            }

            //----- substract-pressure-gradient
            precision highp float;
            @include(common-fluid-compute)

            void main() {
                float left = samplePressure(uPressure, vTexCoord - vec2(uInvResolution.x, 0.0));
                float right = samplePressure(uPressure, vTexCoord + vec2(uInvResolution.x, 0.0));
                float bottom = samplePressure(uPressure, vTexCoord - vec2(0.0, uInvResolution.y));
                float top = samplePressure(uPressure, vTexCoord + vec2(0.0, uInvResolution.y));

                vec2 velocity = sampleVelocity(uVelocity, vTexCoord);
                gl_FragColor = vec4(velocity - 0.5 / uCellSize * vec2(right - left, top - bottom), 0.0, 0.0);
            }

            //----- advect-dye
            precision highp float;
            @include(common-fluid-compute)

            uniform sampler2D uDye;
            void main() {
                vec2 advectionPos = getAdvectionPosition(uVelocity, vWorldPos);
                gl_FragColor = vec4(texture2D(uDye, worldToTexCoord(advectionPos)).xyz, 0.0);
            }

            //----- simple-init-circle
            precision highp float;
            uniform vec4 uValue;
            varying vec2 vWorldPos;
            void main() {
                if (length(vWorldPos) < 1.0 / 40.0) {
                    gl_FragColor = uValue;
                } else {
                    discard;
                }
            }

            //----- draw-velocity
            precision highp float;
            uniform sampler2D uVelocity;
            varying vec2 vTexCoord;
            void main() {
                gl_FragColor = vec4(texture2D(uVelocity, vTexCoord).xy, 0.0, 1.0);
            }

            //----- draw-divergence
            precision highp float;
            uniform sampler2D uDivergence;
            varying vec2 vTexCoord;
            void main() {
                gl_FragColor = vec4(texture2D(uDivergence, vTexCoord).x * 1000.0, 0.0, 0.0, 1.0);
            }

            //----- draw-pressure
            precision highp float;
            uniform sampler2D uPressure;
            varying vec2 vTexCoord;
            void main() {
                gl_FragColor = vec4(texture2D(uPressure, vTexCoord).x * 100.0, 0.0, 0.0, 1.0);
            }

            //----- draw-dye
            precision highp float;
            uniform sampler2D uDye;
            varying vec2 vTexCoord;
            void main() {
                gl_FragColor = vec4(texture2D(uDye, vTexCoord).xyz, 1.0);
            }

            //----- compute-vs
            attribute vec2 aPosition;

            uniform vec2 uAspectRatio;

            varying vec2 vTexCoord;
            varying vec2 vWorldPos;

            void main(void) {
                vTexCoord = aPosition / 2.0 + vec2(0.5, 0.5);
                vWorldPos = aPosition * uAspectRatio;
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
        </script>

        <script type="text/javascript">
            "use strict";

            var FluidSimulation = function(canvas, config) {
                this.canvas = canvas;
                this.config = config;

                this.width = this.canvas.width;
                this.height = this.canvas.height;

                this.simulationWidth = this.width * config.simulationScale;
                this.simulationHeight = this.height * config.simulationScale;
            };

            FluidSimulation.prototype = {
                createComputeTexture: function(components, width, height) {
                    var options = {
                        wrapS: "edge",
                        wrapT: "edge",
                        // TODO become edge
                        minFilter: "linear",
                        magFilter: "linear",
                    };
                    return glExtras.makeHalfFloatComputeTexture(this.gl, components, width, height, options);
                },

                createSimulationTexture: function(components) {
                    return this.createComputeTexture(components, this.simulationWidth, this.simulationHeight);
                },

                createDoubleSimulationTexture: function(components) {
                    return {
                        ping: this.createSimulationTexture(components),
                        pong: this.createSimulationTexture(components),
                        swap: function() {var tmp = this.ping; this.ping = this.pong; this.pong = tmp;},
                    };
                },

                createDisplayTexture: function(components) {
                    return this.createComputeTexture(components, this.width, this.height);
                },

                createDoubleDisplayTexture: function(components) {
                    return {
                        ping: this.createDisplayTexture(components),
                        pong: this.createDisplayTexture(components),
                        swap: function() {var tmp = this.ping; this.ping = this.pong; this.pong = tmp;},
                    };
                },

                createQuadProgram: function(name) {
                    var program = this.shaderPak.createProgram(this.gl, "compute-vs", name);

                    var aspectRatio = [1.0, 1.0];
                    if (this.simulationWidth > this.simulationHeight) {
                        aspectRatio[1] = this.simulationHeight / this.simulationWidth;
                    } else {
                        aspectRatio[0] = this.simulationWidth / this.simulationHeight;
                    }

                    return {
                        program: program,
                        vao: program.createVAO({aPosition: {buffer: this.quadVertices}}),
                        uniforms: {
                            uResolution: [this.simulationWidth, this.simulationHeight],
                            uInvResolution: [1.0 / this.simulationWidth, 1.0 / this.simulationHeight],
                            uAspectRatio: aspectRatio,
                            uCellSize: 1.0 / this.simulationWidth * aspectRatio[0],
                        },
                    }
                },

                renderQuadProgram: function(program, renderTo, uniforms) {
                   uniforms = uniforms || {};

                    program.uniforms["uVelocity"] = this.fluidVelocity.ping;
                    program.uniforms["uDivergence"] = this.fluidDivergence;
                    program.uniforms["uPressure"] = this.fluidPressure.ping;
                    program.uniforms["uForce"] = this.fluidForce;
                    program.uniforms["uDt"] = this.dt;

                    for (var property in uniforms) {
                        program.uniforms[property] = uniforms[property];
                    }

                    if (renderTo) {
                        this.fbo.bind();
                        this.fbo.attach({color: renderTo});
                    } else {
                        this.gl.defaultFramebuffer.bind();
                    }

                    program.program.setUniforms(program.uniforms).use();
                    program.vao.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
                },

                start: function() {
                    this.gl = glUtils.initGL(this.canvas, {
                        extensions: ["ANGLE_instanced_arrays", "OES_texture_float", "OES_texture_float_linear"],
                    });
                    this.frame = 0;

                    // Misc WebGL stuff
                    this.fbo = this.gl.createFBO();
                    this.shaderPak = new glExtras.ShaderPak(document.getElementById("shader-src").textContent);
                    this.quadVertices = this.gl.createArrayBuffer(this.gl.STATIC_DRAW, [
                        -1.0, -1.0,
                         1.0, -1.0,
                        -1.0,  1.0,
                         1.0,  1.0,
                    ]);

                    // Testing programs
                    this.simpleInitCircle = this.createQuadProgram("simple-init-circle");
                    this.drawVelocity = this.createQuadProgram("draw-velocity");
                    this.drawDivergence = this.createQuadProgram("draw-divergence");
                    this.drawDivergence = this.createQuadProgram("draw-pressure");

                    // Compute programs
                    this.advectVelocity = this.createQuadProgram("advect-velocity");
                    this.applyForces = this.createQuadProgram("apply-forces");
                    this.computeDivergence = this.createQuadProgram("compute-divergence");
                    this.solvePressure = this.createQuadProgram("solve-pressure");
                    this.substractPressureGradient = this.createQuadProgram("substract-pressure-gradient");

                    // Create the compute textures
                    this.fluidVelocity = this.createDoubleSimulationTexture(2);
                    this.fluidVelocity.ping.clear([0.0, 0.0, 0.0, 0.0]);

                    this.fluidDivergence = this.createSimulationTexture(1);
                    this.fluidPressure = this.createDoubleSimulationTexture(1);
                    this.fluidForce = this.createSimulationTexture(2);

                    // Init the rest
                    this.initDye();

                    // Run the simulation loop
                    var self = this;
                    this.lastTimestamp = 0;
                    var doFrame = function(timestamp) {
                        if (self.lastTimestamp != 0) {
                            var dt = timestamp - self.lastTimestamp;
                            self.runFrame(dt / 1000);
                        }
                        self.lastTimestamp = timestamp;
                        window.requestAnimationFrame(doFrame);
                    }
                    window.requestAnimationFrame(doFrame);
                },

                runFrame: function(dt) {
                    this.dt = Math.min(dt, 0.01);
                    this.frame ++;

                    // Add inputs to the simulation
                    this.doAddForces();
                    this.doAddDye();

                    // Run the fluid simulation
                    this.doSimulation();

                    // Run the rest of the simulation
                    this.doUpdateDye();

                    // Draw
                    this.doDrawDye();
                },

                //----- DYE
                initDye: function(){
                    this.drawDye = this.createQuadProgram("draw-dye");
                    this.advectDye = this.createQuadProgram("advect-dye");
                    this.dye = this.createDoubleDisplayTexture(3);
                },

                doAddDye: function() {
                    this.gl.viewport(0, 0, this.width, this.height);
                    if (this.frame < this.config.emitFrames) {
                        this.gl.enable(this.gl.BLEND);
                        this.renderQuadProgram(this.simpleInitCircle, this.dye.ping, {uValue: [0.2, 0.7, 0.9, 1.0]});
                        this.gl.disable(this.gl.BLEND);
                    }
                },

                doUpdateDye: function() {
                    this.gl.viewport(0, 0, this.width, this.height);
                    this.renderQuadProgram(this.advectDye, this.dye.pong, {uDye: this.dye.ping});
                    this.dye.swap();
                },

                doDrawDye: function() {
                    this.gl.viewport(0, 0, this.width, this.height);
                    this.renderQuadProgram(this.drawDye, undefined, {uDye: this.dye.ping});
                },

                //----- SIMULATION
                doAddForces: function() {
                    this.gl.viewport(0, 0, this.simulationWidth, this.simulationHeight);
                    // TODO blendmode add
                    if (this.frame < this.config.emitFrames) {
                        this.fluidForce.clear([0.0, 0.0, 0.0, 0.0]);
                        this.renderQuadProgram(this.simpleInitCircle, this.fluidForce, {uValue: [10.0, 0.0, 0.0, 0.0]});
                    }
                },

                doSimulation: function() {
                    this.gl.viewport(0, 0, this.simulationWidth, this.simulationHeight);

                    // Advect velocity
                    this.renderQuadProgram(this.advectVelocity, this.fluidVelocity.pong);
                    this.fluidVelocity.swap();

                    // Add forces
                    this.renderQuadProgram(this.applyForces, this.fluidVelocity.pong);
                    this.fluidVelocity.swap();

                    // Compute divergence
                    this.renderQuadProgram(this.computeDivergence, this.fluidDivergence);

                    // Compute pressure with jacobi iterations
                    this.fluidPressure.ping.clear([0.0, 0.0, 0.0, 0.0]);
                    for (var i = 0; i < this.config.numJacobiIters; i++) {
                        this.renderQuadProgram(this.solvePressure, this.fluidPressure.pong);
                        this.fluidPressure.swap();
                    }

                    // Make the velocity divergence free
                    this.renderQuadProgram(this.substractPressureGradient, this.fluidVelocity.pong);
                    this.fluidVelocity.swap();
                },

            };

            var fluid;
            var start = function() {
                var canvas = document.getElementById("canvas");
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                fluid = new FluidSimulation(document.getElementById("canvas"), {
                    simulationScale: 400 / Math.max(canvas.width, canvas.height),
                    numJacobiIters: 50,
                    emitFrames: 10000,
                });
                fluid.start();
            }
        </script>
    </head>

    <body onload="start();">
        <canvas id="canvas">
            Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
        </canvas>
    </body>
</html>
