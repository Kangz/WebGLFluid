<html>
    <head>
        <title>Unnamed</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

        <style>
            * { margin:0; padding:0; }
        </style>

        <script type="text/javascript" src="external/gl-matrix-min.js"></script>
        <script type="text/javascript" src="lib/glExtras.js"></script>
        <script type="text/javascript" src="lib/glUtils.js"></script>

        <script id="shader-src" type="x-shader/x-shaderpak">
            //----- common-fluid-compute
            uniform sampler2D uVelocity;
            uniform sampler2D uDivergence;
            uniform sampler2D uPressure;
            uniform sampler2D uForce;

            uniform float uDt;
            uniform vec2 uResolution;
            uniform vec2 uInvResolution;
            uniform vec2 uAspectRatio;
            uniform float uCellSize;

            varying vec2 vTexCoord;
            varying vec2 vWorldPos;

            vec2 worldToTexCoord(vec2 world) {
                return (world / uAspectRatio) / 2.0 + vec2(0.5, 0.5);
            }

            vec2 texCoordToWorld(vec2 texCoord) {
                return (texCoord - vec2(0.5, 0.5)) * 2.0 * uAspectRatio;
            }

            vec2 sampleVelocity(sampler2D velocity, vec2 texCoord) {
                vec2 offset = vec2(0.0, 0.0);
                vec2 multiplier = vec2(1.0, 1.0);

                // TODO replace with the obstacle texture
                if (texCoord.x < 0.0) {
                    offset.x = uInvResolution.x;
                    multiplier.x = -1.0;
                } else if (texCoord.x > 1.0) {
                    offset.x = -uInvResolution.x;
                    multiplier.x = -1.0;
                }
                if (texCoord.y < 0.0) {
                    offset.y = uInvResolution.y;
                    multiplier.y = -1.0;
                } else if (texCoord.y > 1.0) {
                    offset.y = -uInvResolution.y;
                    multiplier.y = -1.0;
                }

                return multiplier * texture2D(velocity, texCoord + offset).xy;
            }

            float samplePressure(sampler2D pressure, vec2 texCoord) {
                vec2 offset = vec2(0.0, 0.0);

                // TODO replace with the obstacle texture
                if (texCoord.x < 0.0) {
                    offset.x = uInvResolution.x;
                } else if (texCoord.x > 1.0) {
                    offset.x = -uInvResolution.x;
                }
                if (texCoord.y < 0.0) {
                    offset.y = uInvResolution.y;
                } else if (texCoord.y > 1.0) {
                    offset.y = -uInvResolution.y;
                }

                return texture2D(pressure, texCoord + offset).x;
            }

            vec2 getAdvectionPosition(sampler2D velocity, vec2 worldPos) {
                //TODO try MacCormack
                return worldPos - sampleVelocity(uVelocity, worldToTexCoord(worldPos)) * uDt;
            }

            //----- advect-velocity
            precision highp float;
            @include(common-fluid-compute)

            void main() {
                vec2 advectionPos = getAdvectionPosition(uVelocity, vWorldPos);
                gl_FragColor = vec4(texture2D(uVelocity, worldToTexCoord(advectionPos)).xy, 0.0, 0.0);
            }

            //----- apply-forces
            precision highp float;
            @include(common-fluid-compute)

            void main() {
                vec2 velocity = sampleVelocity(uVelocity, vTexCoord);
                vec2 force = texture2D(uForce, vTexCoord).xy;
                gl_FragColor = vec4(velocity + force * uDt, 0.0, 0.0);
            }

            //----- compute-divergence
            precision highp float;
            @include(common-fluid-compute)

            void main() {
                vec2 left = sampleVelocity(uVelocity, vTexCoord - vec2(uInvResolution.x, 0.0));
                vec2 right = sampleVelocity(uVelocity, vTexCoord + vec2(uInvResolution.x, 0.0));
                vec2 bottom = sampleVelocity(uVelocity, vTexCoord - vec2(0.0, uInvResolution.y));
                vec2 top = sampleVelocity(uVelocity, vTexCoord + vec2(0.0, uInvResolution.y));

                float divergence = 0.5 / uCellSize * (right.x - left.x + top.y - bottom.y);
                gl_FragColor = vec4(divergence, 0.0, 0.0, 0.0);
            }

            //----- solve-pressure
            precision highp float;
            @include(common-fluid-compute)

            void main() {
                float left = samplePressure(uPressure, vTexCoord - vec2(uInvResolution.x, 0.0));
                float right = samplePressure(uPressure, vTexCoord + vec2(uInvResolution.x, 0.0));
                float bottom = samplePressure(uPressure, vTexCoord - vec2(0.0, uInvResolution.y));
                float top = samplePressure(uPressure, vTexCoord + vec2(0.0, uInvResolution.y));

                float divergence = texture2D(uDivergence, vTexCoord).x;
                float pressure = (left + right + bottom + top - divergence * uCellSize * uCellSize) / 4.0;
                gl_FragColor = vec4(pressure, 0.0, 0.0, 0.0);
            }

            //----- substract-pressure-gradient
            precision highp float;
            @include(common-fluid-compute)

            void main() {
                float left = samplePressure(uPressure, vTexCoord - vec2(uInvResolution.x, 0.0));
                float right = samplePressure(uPressure, vTexCoord + vec2(uInvResolution.x, 0.0));
                float bottom = samplePressure(uPressure, vTexCoord - vec2(0.0, uInvResolution.y));
                float top = samplePressure(uPressure, vTexCoord + vec2(0.0, uInvResolution.y));

                vec2 velocity = sampleVelocity(uVelocity, vTexCoord);
                gl_FragColor = vec4(velocity - 0.5 / uCellSize * vec2(right - left, top - bottom), 0.0, 0.0);
            }

            //----- advect-dye
            precision highp float;
            @include(common-fluid-compute)

            uniform sampler2D uDye;
            void main() {
                vec2 advectionPos = getAdvectionPosition(uVelocity, vWorldPos);
                gl_FragColor = vec4(texture2D(uDye, worldToTexCoord(advectionPos)).xyz, 0.0);
            }

            //----- simple-init-circle
            precision highp float;
            uniform vec4 uValue;
            uniform vec2 uTargetPos;
            uniform float uRadius;
            varying vec2 vWorldPos;
            void main() {
                if (length(vWorldPos - uTargetPos) < uRadius) {
                    gl_FragColor = uValue;
                } else {
                    discard;
                }
            }

            //----- draw-velocity
            precision highp float;
            uniform sampler2D uVelocity;
            varying vec2 vTexCoord;
            void main() {
                gl_FragColor = vec4(texture2D(uVelocity, vTexCoord).xy, 0.0, 1.0);
            }

            //----- draw-divergence
            precision highp float;
            uniform sampler2D uDivergence;
            varying vec2 vTexCoord;
            void main() {
                gl_FragColor = vec4(texture2D(uDivergence, vTexCoord).x * 1000.0, 0.0, 0.0, 1.0);
            }

            //----- draw-pressure
            precision highp float;
            uniform sampler2D uPressure;
            varying vec2 vTexCoord;
            void main() {
                gl_FragColor = vec4(texture2D(uPressure, vTexCoord).x * 100.0, 0.0, 0.0, 1.0);
            }

            //----- draw-dye
            precision highp float;
            uniform sampler2D uDye;
            varying vec2 vTexCoord;
            void main() {
                gl_FragColor = vec4(texture2D(uDye, vTexCoord).xyz, 1.0);
            }

            //----- compute-vs
            attribute vec2 aPosition;

            uniform vec2 uAspectRatio;

            varying vec2 vTexCoord;
            varying vec2 vWorldPos;

            void main(void) {
                vTexCoord = aPosition / 2.0 + vec2(0.5, 0.5);
                vWorldPos = aPosition * uAspectRatio;
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
        </script>

        <script type="text/javascript">
            "use strict";

            var FluidSimulation = function(canvas, config) {
                this.canvas = canvas;
                this.config = config;

                this.width = this.canvas.width;
                this.height = this.canvas.height;

                this.simulationWidth = this.width * config.simulationScale;
                this.simulationHeight = this.height * config.simulationScale;

                this.aspectRatio = [1.0, 1.0];
                if (this.simulationWidth > this.simulationHeight) {
                    this.aspectRatio[1] = this.simulationHeight / this.simulationWidth;
                } else {
                    this.aspectRatio[0] = this.simulationWidth / this.simulationHeight;
                }
            };

            FluidSimulation.prototype = {
                createComputeTexture: function(components, width, height) {
                    var options = {
                        wrapS: "edge",
                        wrapT: "edge",
                        // TODO become edge
                        minFilter: "linear",
                        magFilter: "linear",
                    };
                    return glExtras.makeHalfFloatComputeTexture(this.gl, components, width, height, options);
                },

                createSimulationTexture: function(components) {
                    return this.createComputeTexture(components, this.simulationWidth, this.simulationHeight);
                },

                createDoubleSimulationTexture: function(components) {
                    return {
                        ping: this.createSimulationTexture(components),
                        pong: this.createSimulationTexture(components),
                        swap: function() {var tmp = this.ping; this.ping = this.pong; this.pong = tmp;},
                    };
                },

                createDisplayTexture: function(components) {
                    return this.createComputeTexture(components, this.width, this.height);
                },

                createDoubleDisplayTexture: function(components) {
                    return {
                        ping: this.createDisplayTexture(components),
                        pong: this.createDisplayTexture(components),
                        swap: function() {var tmp = this.ping; this.ping = this.pong; this.pong = tmp;},
                    };
                },

                createQuadProgram: function(name) {
                    var program = this.shaderPak.createProgram(this.gl, "compute-vs", name);

                    return {
                        program: program,
                        vao: program.createVAO({aPosition: {buffer: this.quadVertices}}),
                        uniforms: {
                            uResolution: [this.simulationWidth, this.simulationHeight],
                            uInvResolution: [1.0 / this.simulationWidth, 1.0 / this.simulationHeight],
                            uAspectRatio: this.aspectRatio,
                            uCellSize: 1.0 / this.simulationWidth * this.aspectRatio[0],
                        },
                    }
                },

                canvasToWorld: function(pos) {
                    return [
                        (pos[0] / this.width * 2.0 - 1.0) * this.aspectRatio[0],
                        (pos[1] / this.height * -2.0 + 1.0) * this.aspectRatio[1],
                    ];
                },

                renderQuadProgram: function(program, renderTo, uniforms) {
                    uniforms = uniforms || {};

                    program.uniforms["uVelocity"] = this.fluidVelocity.ping;
                    program.uniforms["uDivergence"] = this.fluidDivergence;
                    program.uniforms["uPressure"] = this.fluidPressure.ping;
                    program.uniforms["uForce"] = this.fluidForce;
                    program.uniforms["uDt"] = this.dt;

                    for (var property in uniforms) {
                        program.uniforms[property] = uniforms[property];
                    }

                    if (renderTo) {
                        this.fbo.bind();
                        this.fbo.attach({color: renderTo});
                    } else {
                        this.gl.defaultFramebuffer.bind();
                    }

                    program.program.setUniforms(program.uniforms).use();
                    program.vao.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
                },

                start: function() {
                    this.gl = glUtils.initGL(this.canvas, {
                        extensions: ["ANGLE_instanced_arrays", "OES_texture_float", "OES_texture_float_linear"],
                    });

                    // Misc WebGL stuff
                    this.fbo = this.gl.createFBO();
                    this.shaderPak = new glExtras.ShaderPak(document.getElementById("shader-src").textContent);
                    this.quadVertices = this.gl.createArrayBuffer(this.gl.STATIC_DRAW, [
                        -1.0, -1.0,
                         1.0, -1.0,
                        -1.0,  1.0,
                         1.0,  1.0,
                    ]);

                    // Testing programs
                    this.simpleInitCircle = this.createQuadProgram("simple-init-circle");
                    this.drawVelocity = this.createQuadProgram("draw-velocity");
                    this.drawDivergence = this.createQuadProgram("draw-divergence");
                    this.drawDivergence = this.createQuadProgram("draw-pressure");

                    // Compute programs
                    this.advectVelocity = this.createQuadProgram("advect-velocity");
                    this.applyForces = this.createQuadProgram("apply-forces");
                    this.computeDivergence = this.createQuadProgram("compute-divergence");
                    this.solvePressure = this.createQuadProgram("solve-pressure");
                    this.substractPressureGradient = this.createQuadProgram("substract-pressure-gradient");

                    // Create the compute textures
                    this.fluidVelocity = this.createDoubleSimulationTexture(2);
                    this.fluidVelocity.ping.clear([0.0, 0.0, 0.0, 0.0]);

                    this.fluidDivergence = this.createSimulationTexture(1);
                    this.fluidPressure = this.createDoubleSimulationTexture(1);
                    this.fluidForce = this.createSimulationTexture(2);

                    // Init the rest
                    this.initDye();
                },

                runFrame: function(dt) {
                    this.dt = Math.min(dt, 0.01);

                    // Add inputs to the simulation
                    this.doAddForces();
                    this.doAddDye();

                    // Run the fluid simulation
                    this.doSimulation();

                    // Run the rest of the simulation
                    this.doUpdateDye();

                    // Draw
                    this.doDrawDye();
                },

                //----- DYE
                initDye: function(){
                    this.drawDye = this.createQuadProgram("draw-dye");
                    this.advectDye = this.createQuadProgram("advect-dye");
                    this.dye = this.createDoubleDisplayTexture(3);
                },

                doAddDye: function() {
                    this.gl.viewport(0, 0, this.width, this.height);
                    this.gl.enable(this.gl.BLEND);

                    this.onAddDye && this.onAddDye(this.dye.ping);

                    this.gl.disable(this.gl.BLEND);
                },

                doUpdateDye: function() {
                    this.gl.viewport(0, 0, this.width, this.height);
                    this.renderQuadProgram(this.advectDye, this.dye.pong, {uDye: this.dye.ping});
                    this.dye.swap();
                },

                doDrawDye: function() {
                    this.gl.viewport(0, 0, this.width, this.height);
                    this.renderQuadProgram(this.drawDye, undefined, {uDye: this.dye.ping});
                },

                //----- SIMULATION
                doAddForces: function() {
                    this.gl.viewport(0, 0, this.simulationWidth, this.simulationHeight);
                    this.fluidForce.clear([0.0, 0.0, 0.0, 0.0]);
                    // TODO blendmode add
                    this.onAddForces && this.onAddForces(this.fluidForce);
                },

                doSimulation: function() {
                    this.gl.viewport(0, 0, this.simulationWidth, this.simulationHeight);

                    // Advect velocity
                    this.renderQuadProgram(this.advectVelocity, this.fluidVelocity.pong);
                    this.fluidVelocity.swap();

                    // Add forces
                    this.renderQuadProgram(this.applyForces, this.fluidVelocity.pong);
                    this.fluidVelocity.swap();

                    // Compute divergence
                    this.renderQuadProgram(this.computeDivergence, this.fluidDivergence);

                    // Compute pressure with jacobi iterations
                    this.fluidPressure.ping.clear([0.0, 0.0, 0.0, 0.0]);
                    for (var i = 0; i < this.config.numJacobiIters; i++) {
                        this.renderQuadProgram(this.solvePressure, this.fluidPressure.pong);
                        this.fluidPressure.swap();
                    }

                    // Make the velocity divergence free
                    this.renderQuadProgram(this.substractPressureGradient, this.fluidVelocity.pong);
                    this.fluidVelocity.swap();
                },

            };

            var fluid;
            var start = function() {
                var canvas = document.getElementById("canvas");
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                var lastTimestamp = 0;

                fluid = new FluidSimulation(document.getElementById("canvas"), {
                    simulationScale: 400 / Math.max(canvas.width, canvas.height),
                    numJacobiIters: 50,
                });

                // Drawing stuff with the mouse
                // TODO make it draw segments instead of circles
                var lastMousePos = [0.0, 0.0];
                var mousePos = [0.0, 0.0];
                var mouseForce = [0.0, 0.0];
                var mouseDown = false;

                fluid.onAddDye = function(dyeOut) {
                    if (!mouseDown) {
                        return;
                    }
                    fluid.renderQuadProgram(fluid.simpleInitCircle, dyeOut, {
                        uValue: [0.2, 0.7, 0.9, 1.0],
                        uTargetPos: mousePos,
                        uRadius: 0.02,
                    });
                };

                fluid.onAddForces = function(forcesOut) {
                    if (!mouseDown) {
                        return;
                    }
                    fluid.renderQuadProgram(fluid.simpleInitCircle, forcesOut, {
                        uValue: mouseForce.concat([0.0, 0.0]),
                        uTargetPos: mousePos,
                        uRadius: 0.02,
                    });
                };

                fluid.start();

                var updateMouse = function(e) {
                    mouseDown = e.buttons & 1;
                    mousePos = fluid.canvasToWorld([e.clientX, e.clientY]);
                };
                canvas.addEventListener("mouseleave", function(e){mouseDown = false});
                canvas.addEventListener("mouseenter", function(e){updateMouse(e)});
                canvas.addEventListener("mousedown", function(e){updateMouse(e)});
                canvas.addEventListener("mouseup", function(e){updateMouse(e)});
                canvas.addEventListener("mousemove", function(e){updateMouse(e)});

                var frame = function(dt) {
                    mouseForce[0] = (mousePos[0] - lastMousePos[0]) / dt / dt;
                    mouseForce[1] = (mousePos[1] - lastMousePos[1]) / dt / dt;
                    lastMousePos = mousePos;
                }

                // Run the simulation loop
                var frameLoop = function(timestamp) {
                    if (lastTimestamp != 0) {
                        var dt = timestamp - lastTimestamp;
                        frame(dt / 1000);
                        fluid.runFrame(dt / 1000);
                    }
                    lastTimestamp = timestamp;
                    window.requestAnimationFrame(frameLoop);
                }
                window.requestAnimationFrame(frameLoop);
            }
        </script>
    </head>

    <body onload="start();">
        <canvas id="canvas">
            Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
        </canvas>
    </body>
</html>
